//! Time synchronized input and output components for audio devices.
//!
//! A device that generates audio should use an `OutputChannelArray`. An output
//! array create a number of output channels to contain audio generated by our
//! device; the device is responsible for pushing new audio into these channels.
//! 
//! A device that takes in audio should use an `InputChannelArray`. An input
//! array starts with each of its inputs set to `None`. These must be populated
//! with `ChannelRef`s from one or more output arrays before they will receive
//! input data.
//! 
//! A device may contain both an input and an output component, and use its
//! inputs to generate its outputs.

#![experimental]

use std::cell::RefCell;
use std::rc::Rc;
use std::vec::Vec;

use core::{Sample, Time};


/// Stores generated audio data and manages access to that data.
#[experimental]
pub struct OutputChannelArray {
    chs: Vec<ChannelRef>
}

impl OutputChannelArray {
    /// Creates a new output array with `num_channels` channels.
    ///
    /// These channels are initialized at time 0.
    pub fn new(num_channels: uint) -> OutputChannelArray {
        let mut chs = Vec::with_capacity(num_channels);
        for _ in range(0, num_channels) {
            chs.push(Rc::new(RefCell::new(Channel::new())));
        }
        OutputChannelArray { chs: chs }
    }
    
    /// Returns the number of output channels
    pub fn get_num_channels(&self) -> uint {
        self.chs.len()
    }

    /// Returns a reference to channel `i`.
    pub fn get_channel(&self, i: uint) -> ChannelRef {
        self.chs[i].clone()
    }

    /// Attempts to get the sample from time `t` in channel `i`.
    pub fn get_sample(&self, i: uint, t: Time) -> Option<Sample> {
        self.chs[i].borrow_mut().get(t)
    }

    /// Pushes the next sample to channel `i`.
    pub fn push_sample(&self, i: uint, s: Sample) {
        self.chs[i].borrow_mut().push(s);
    }
}


/// Holds references to channels to draw input audio data from.
#[experimental]
pub struct InputChannelArray {
    chs: Vec<Option<ChannelRef>>
}

impl InputChannelArray {
    /// Creates a new input array that can receive from `num_channels channels.
    /// 
    /// These channels are initialized as empty, and must be filled to return
    /// input data.
    pub fn new(num_channels: uint) -> InputChannelArray {
        let mut chs = Vec::with_capacity(num_channels);
        for _ in range(0, num_channels) {
            chs.push(None);
        }
        InputChannelArray { chs: chs }
    }

    /// Returns the number of input channels
    pub fn get_num_channels(&self) -> uint {
        self.chs.len()
    }

    /// Sets channel `i` to read from `channel`.
    pub fn set_channel(&mut self, i: uint, channel: ChannelRef) {
        self.chs[i] = Some(channel);
    }

    /// Sets channel `i` to empty.
    pub fn remove_channel(&mut self, i: uint) {
        self.chs[i] = None;
    }

    /// Attempts to return the value of channel `i` at time `t`.
    ///
    /// Returns `None` if either channel `i` is empty, or if channel `i` could
    /// not return the sample for time `t`.
    pub fn get_sample(&self, i: uint, t: Time) -> Option<Sample> {
        match self.chs[i] {
            Some(ref ch) => ch.borrow().get(t),
            None => None
        }
    }
}


/// A reference to a channel, used to link outputs to inputs.
pub type ChannelRef = Rc<RefCell<Channel>>;


/// Container for a single channel of audio.
#[experimental]
struct Channel {
    t: Time,
    s: Sample,
}

impl Channel {
    /// Returns a new channel, initialized to time 0
    pub fn new() -> Channel {
        Channel{ t: 0, s: 0.0 }
    }

    /// Attempts to return the sample for time `t`.
    ///
    /// Returns `None` if we don't have the requested time.
    pub fn get(&self, t: Time) -> Option<Sample> {
        if t != self.t {
            None
        } else {
            Some(self.s)
        }
    }

    /// Add the next sample to the channel
    pub fn push(&mut self, s: Sample) {
        self.t += 1;
        self.s = s;
    }
}
